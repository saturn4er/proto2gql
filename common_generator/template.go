package common_generator

const headTemplate = `
// This file was generated by github.com/saturn4er/proto2gql. DO NOT EDIT IT
package {{$.package}}

import (
{{range $import := $.imports}}
	{{$import.Alias}} "{{$import.Path}}"
{{end}}
)
`

const bodyTemplate = `
// Enums
{{range $enum := .File.Enums -}}
	var {{$enum.VariableName}} = {{gqlPkg}}.NewEnum({{gqlPkg}}.EnumConfig{
		Name:        "{{$enum.GraphQLName}}",
		{{ if $enum.Comment -}}
			Description: {{$enum.Comment}},
		{{ end -}}
		Values: {{gqlPkg}}.EnumValueConfigMap{
            {{range $value := $enum.Values -}}
				"{{$value.Name}}": &{{gqlPkg}}.EnumValueConfig{
					Value: {{$value.Value}},
					{{ if ne $value.Comment "\"\"" -}} 
						Description: {{$value.Comment}},
					{{ end -}}
				},
			{{end -}}
		},
	})
{{end -}}


// Input object
{{ range $object := .File.InputObjects -}}
	var {{$object.VariableName}} = {{gqlPkg}}.NewInputObject({{gqlPkg}}.InputObjectConfig{
        Name: "{{$object.GraphQLName}}",
        Fields: {{gqlPkg}}.InputObjectConfigFieldMapThunk(func() {{gqlPkg}}.InputObjectConfigFieldMap {
            return {{gqlPkg}}.InputObjectConfigFieldMap{
                {{range $field := $object.Fields -}}
                    "{{$field.Name}}": &{{gqlPkg}}.InputObjectFieldConfig{
						Type: {{call $field.Type $}},
                    },
                {{end -}}
            }
        }),
    })	
{{ end -}}

// Input objects resolvers
{{ range $resolver := .File.InputObjectResolvers -}}
func {{$resolver.FunctionName}}({{ if $.TracerEnabled }} tr {{tracerPkg}}.Tracer, {{end}}ctx {{ctxPkg}}.Context, i interface{}) (_ *{{$resolver.OutputGoType}}, rerr error){
	{{ if $.TracerEnabled -}}
		span := tr.CreateChildSpanFromContext(ctx, "{{$resolver.FunctionName}}")
		defer span.Finish()
		defer func(){
			if perr := recover(); perr != nil {
				span.SetTag("error", "true")
				span.SetTag("error_message", perr)
				span.SetTag("error_stack", string({{debugPkg}}.Stack()))
			}
			if rerr != nil {
				span.SetTag("error", "true")
				span.SetTag("error_message", rerr.Error())
			}
		}()
	{{end -}}
	if i == nil {
		return nil, nil
	}
	args := i.(map[string]interface{})
	_ = args
	var result = new({{$resolver.OutputGoType}})
	{{ range $field := $resolver.Fields -}}
		if args["{{$field.GraphqlInputField}}"] != nil {
			{{ if isArray $field.GoType -}}
        	in := args["{{$field.GraphqlInputField}}"].([]interface{})
			result.{{$field.Name}} = make({{goType $field.GoType}}, len(in))
			for i, val := range in {
				{{ if $field.ResolverWithError }}
					v, err := {{call $field.ValueResolver "val" $}}
					if err != nil {
						return errors.Wrap("")
					}
					result.{{$field.Name}}[i] = v
				{{ else -}}
					result.{{$field.Name}}[i] = {{call $field.ValueResolver "val" $}}
				{{ end -}}
				
			}
			{{ else -}}
				result.{{$field.Name}} = {{call $field.ValueResolver (concat "args[\"" $field.GraphqlInputField "\"]") $}}
			{{ end -}}
		}
	{{ end -}}

	return result, nil
}
{{ end -}}
// Output objects
{{ range $object := $.File.OutputObjects -}}
	var {{$object.VariableName}} = {{gqlPkg}}.NewObject({{gqlPkg}}.ObjectConfig{
		Name: "{{$object.GraphQLName}}",
           Fields: {{gqlPkg}}.Fields{
		},
	})
	func init(){
		{{ range $field := $object.Fields -}}
			{{$object.VariableName}}.AddFieldConfig("{{$field.Name}}", &{{gqlPkg}}.Field{
				Name: "{{.Name}}",
				Type: {{call $field.Type $}},
				Resolve: func(p {{gqlPkg}}.ResolveParams) (interface{}, error) {
        	    	switch src := p.Source.(type){
						case *{{goType $field.GoObjectType}}:
							if src == nil {
								return nil, nil
							}
							{{if $field.NeedCast -}}
								return {{$field.CastTo}}(src.{{$field.GoObjectField}}), nil
							{{else -}}
								return src.{{$field.GoObjectField}}, nil
							{{ end -}}
						case {{goType $field.GoObjectType}}:
							{{if $field.NeedCast -}}
								return {{$field.CastTo}}(src.{{$field.GoObjectField}}), nil
							{{else -}}
								return src.{{$field.GoObjectField}}, nil
							{{end -}}
					}
					return nil, {{errorsPkg}}.New("source of unknown type")
				},
			})
		{{ end -}}
	}
{{ end -}}
// Maps input objects
{{ range $object := .File.MapInputObjects -}}
	var {{$object.VariableName}} = {{gqlPkg}}.NewInputObject({{gqlPkg}}.InputObjectConfig{
        Name: "{{$object.GraphQLName}}",
        Fields: {{gqlPkg}}.InputObjectConfigFieldMapThunk(func() {{gqlPkg}}.InputObjectConfigFieldMap {
            return {{gqlPkg}}.InputObjectConfigFieldMap{
				"key": &{{gqlPkg}}.InputObjectFieldConfig{
					Type: {{call $object.KeyObjectType $}},
				},
    	        "value": &{{gqlPkg}}.InputObjectFieldConfig{
    	            Type: {{call $object.ValueObjectType $}},
    	        },
            }
        }),
    })	
{{ end -}}
// Maps input obects resolvers
{{ range $resolver := .File.MapInputObjectResolvers -}}
	func {{$resolver.FunctionName}}({{ if $.TracerEnabled }} tr {{tracerPkg}}.Tracer, {{end}}ctx {{ctxPkg}}.Context, i interface{}) (_ map[{{$resolver.KeyGoType}}]{{$resolver.ValueGoType}}, rerr error){
		{{ if $.TracerEnabled -}}
			span := tr.CreateChildSpanFromContext(ctx, "{{$resolver.FunctionName}}")
			defer span.Finish()
			defer func(){
				if perr := recover(); perr != nil {
					span.SetTag("error", "true")
					span.SetTag("error_message", perr)
					span.SetTag("error_stack", string({{debugPkg}}.Stack()))
				}
				if rerr != nil {
					span.SetTag("error", "true")
					span.SetTag("error_message", rerr.Error())
				}
			}()
		{{end -}}
		if i == nil {
			return nil, nil
		}
		in := i.([]interface{})
		result := make(map[{{$resolver.KeyGoType}}]{{$resolver.ValueGoType}})
		for i, ival := range in {
			_ = i
			val := ival.(map[string]interface{})
			k, v := val["key"], val["value"]
			_, _ = k,v
			{{if $resolver.KeyResolverWithError -}}
				kk, err := {{call $resolver.KeyResolver "k" $}}
				if err != nil {
					return nil, {{errorsPkg}}.Wrapf(err, "failed to resolve #%d map element key", i)
				}
			{{else -}}
				kk := {{call $resolver.KeyResolver "k" $}}
			{{end -}}
			{{if $resolver.ValueResolverWithError -}}
				vv, err := {{call $resolver.ValueResolver "v" $}}
				if err != nil {
					return nil, {{errorsPkg}}.Wrapf(err, "failed to resolve #%d map element value", i)
				}
			{{else -}}
				vv := {{call $resolver.ValueResolver "v" $}}
			{{end -}}
			result[kk]=vv
		}
		return result, nil
	}
{{ end -}}

// Maps output objects
{{ range $object := .File.MapOutputObjects -}}
	var {{$object.VariableName}} = {{gqlPkg}}.NewObject({{gqlPkg}}.ObjectConfig{
		Name: "{{$object.GraphQLName}}",
       	Fields: {{gqlPkg}}.Fields{
		},
	})
	func init(){
		{{$object.VariableName}}.AddFieldConfig("key", &{{gqlPkg}}.Field{
			Name: "key",
			Type: {{call $object.KeyObjectType $}},
			Resolve: func(p {{gqlPkg}}.ResolveParams) (interface{}, error) {
				src := p.Source.(map[string]interface{})
				if src == nil {
					return nil, nil
				}
				return src["key"].({{goType $object.KeyGoType}}), nil
			},
		})
		{{$object.VariableName}}.AddFieldConfig("value", &{{gqlPkg}}.Field{
			Name: "value",
			Type: {{call $object.KeyObjectType $}},
			Resolve: func(p {{gqlPkg}}.ResolveParams) (interface{}, error) {
				src := p.Source.(map[string]interface{})
				if src == nil {
					return nil, nil
				}
				return src["value"].({{goType $object.ValueGoType}}), nil
			},
		})
	}
{{end -}}

// Services


`
